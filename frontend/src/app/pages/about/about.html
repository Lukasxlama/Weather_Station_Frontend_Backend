<app-page-shell [title]="'√úber das Projekt'" [dividers]="'both'">    
    <div class="desc-carousel">
        <div class="desc-text">
            <section class="mb-5">
                <h4>Idee & Motivation</h4>
                <p>
                    Kurz gesagt: Aus einer Mischung aus Neugier und Lust auf ein neues Projekt entstand die Idee, etwas Eigenes zu
                    bauen,
                    bei dem wir nicht nur Spa√ü haben, sondern auch eine Menge dazulernen k√∂nnen ‚Äì und das Ganze idealerweise mit
                    einem praktischen Nutzen.
                </p>
                <p>
                    Nach einigem √úberlegen fiel die Wahl schnell auf eine Outdoor-Wetterstation.
                    Erste Inspiration und Grundlagen haben wir uns durch YouTube-Videos geholt, um einen √úberblick zu bekommen.
                </p>
                <p>
                    Unsere Motivation war es, verl√§ssliche Messwerte zu gewinnen und dabei in m√∂glichst viele spannende Themenfelder
                    einzutauchen ‚Äì von Mikroelektronik und Funktechnik bis hin zu Software-Entwicklung und Middleware.
                </p>
            </section>
            
            <section class="mb-5">
                <h4>Hardware</h4>
                <p>
                    Das Herzst√ºck der Station bildet ein ESP32 Dev Module ‚Äì ein stromsparender Mikrocontroller mit
                    gen√ºgend Leistung f√ºr Sensorabfragen und die drahtlose Daten√ºbertragung.
                    Angeschlossen ist ein BME680-Sensor, der Temperatur, Luftfeuchtigkeit,
                    Luftdruck und den Gaswiderstand erfasst.
                </p>
                <p>
                    Die Energieversorgung √ºbernehmen zwei Solarpanels mit jeweils 5 W, die einen
                    3.200 mAh Li-Ion-Akku laden. Dadurch arbeitet die Station v√∂llig autark ‚Äì
                    sogar in den dunkleren Wintermonaten.
                </p>
                <p>
                    Untergebracht ist die Elektronik in einem wetterfesten Outdoor-Geh√§use, erg√§nzt durch
                    eine 3D-gedruckte Halterungen f√ºr den BME680. Damit ist die Station robust genug,
                    um ganzj√§hrig Wind und Wetter standzuhalten.
                </p>
            </section>
            
            <section class="mb-5">
                <h4>ESP32 Code</h4>
                <p>
                    Der Code f√ºr den ESP32 ist modular aufgebaut. Sensor, Display und LoRa-Funk sind in eigene Manager ausgelagert
                    und √ºber eine zentrale Konfiguration steuerbar. So bleibt das Projekt √ºbersichtlich und leicht erweiterbar.
                </p>
                <p>
                    Alle Einstellungen wie aktivierte Module, Pins und Betriebsarten werden in einer <code>Config.hpp</code>
                    festgelegt. Dadurch l√§sst sich der Build komplett anpassen, ohne den eigentlichen Code √§ndern zu m√ºssen.
                </p>
                <p>
                    Die Komponenten sind einfach, aber zuverl√§ssig umgesetzt. In der <code>main.cpp</code> werden sie
                    zusammengef√ºhrt, initialisiert und nacheinander ausgef√ºhrt. So liest der ESP32 die Sensordaten aus, zeigt sie
                    bei Bedarf auf dem Display an und sendet sie √ºber LoRa weiter.
                </p>
                <p>
                    Quellcode: <a href="https://github.com/Lukasxlama/weather_station_esp32">weather_station_esp32</a>
                </p>
            </section>
            
            <section class="mb-5">
                <h4>Middleware (LoRa ‚Üí MQTT)</h4>
                <p>
                    Die Middleware l√§uft auf dem Raspberry&nbsp;Pi und verbindet den LoRa-Empf√§nger mit einem MQTT-Broker.
                    Sie ist bewusst schlank gehalten und trennt klar zwischen Empfang, Verarbeitung und Weitergabe der Daten.
                </p>
                <p>
                    Alle Einstellungen wie MQTT-Host, Pins und Logging werden zentral in einer <code>.env</code>-Datei konfiguriert.
                    Installation und Betrieb erfolgen bequem √ºber die mitgelieferten Skripte, die automatisch ein virtuelles
                    Environment
                    und einen systemd-Service einrichten.
                </p>
                <p>
                    √úber MQTT werden die Wetterdaten in strukturierter Form als JSON und einzeln pro Feld bereitgestellt. So stehen
                    sie
                    sowohl f√ºr Home Assistant als auch f√ºr das Backend der Website direkt zur Verf√ºgung.
                </p>
                <p>
                    Quellcode: <a href="https://github.com/Lukasxlama/weather_station_middleware">weather_station_middleware</a>
                </p>
            </section>

            <section class="mb-5">
                <h4>üå± Installation im Garten</h4>
                <p>
                    Die Station ist auf einem stabilen Baumstumpf montiert, erh√∂ht durch eine PVC-R√∂hre,
                    um St√∂rungen durch Bodenn√§he zu vermeiden. So werden die Messwerte pr√§ziser und
                    repr√§sentativer f√ºr die Umgebung.
                </p>
                <p>
                    Im Alltag liefert die Station <b>verl√§ssliche Live-Daten</b>,
                    die nicht nur spannend zu beobachten sind, sondern auch ganz praktisch genutzt werden k√∂nnen ‚Äì
                    etwa um L√ºften besser zu timen oder Wetterumschw√ºnge fr√ºh zu bemerken.
                </p>
            </section>
            
            <section>
                <h4>üöÄ Fazit</h4>
                <p>
                    Aus einer Idee ist ein vollst√§ndiges System geworden:
                    eine <b>energieautarke, smarte Wetterstation</b>, die durch
                    <strong>Do-it-yourself</strong>-Ansatz, moderne Technologien und
                    robuste Bauweise √ºberzeugt.
                </p>
                <p>
                    Das Projekt w√§chst weiter ‚Äì von zus√§tzlichen Sensoren bis hin zu
                    intelligenten Auswertungen mit Machine Learning sind viele Erweiterungen denkbar.
                    Und genau das macht es so spannend!
                </p>
            </section>
        </div>

        <app-divider></app-divider>
        <h2 class="mb-4">üñºÔ∏è Bilder</h2>
        <div class="carousel-box mt-4">
            <div #stationCarouselEl id="stationCarousel" class="carousel slide carousel-dark" data-bs-ride="carousel"
                data-bs-touch="true" data-bs-interval="3000">

                <div class="carousel-viewport position-relative">
                    <div class="carousel-inner">
                        @for (img of images; let i = $index; track i) {
                        <div class="carousel-item" [class.active]="i === 0">
                            <img [src]="img.src" [alt]="img.alt" class="carousel-img" loading="lazy">
                        </div>
                        }
                    </div>

                    @if (images.length)
                    {
                    <div class="caption-glass" [class.is-switching]="isSwitching">
                        <h5 class="m-0 text-truncate">
                            {{ images[activeIndex].title }}
                        </h5>
                    </div>
                    }
                </div>

                <button class="carousel-control-prev" type="button" data-bs-target="#stationCarousel"
                    data-bs-slide="prev">
                    <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                    <span class="visually-hidden">Previous</span>
                </button>

                <button class="carousel-control-next" type="button" data-bs-target="#stationCarousel"
                    data-bs-slide="next">
                    <span class="carousel-control-next-icon" aria-hidden="true"></span>
                    <span class="visually-hidden">Next</span>
                </button>
            </div>
        </div>
    </div>
</app-page-shell>